#!/bin/bash

toggledisplay_usage()
{
cat << EOF
usage: toggledisplay [OPTIONS]

Provides a simple interface for toggling / mirroring external displays.

OPTIONS:
   -h             Show this message
   -t             Toggle internal / external monitor
   -m             Attempt to mirror displays
   -d             Disconnect all external monitors, enable internal
   -e [monitors]  Use [monitors] as the list of external displays for
                  the operation

NOTE: all options are mutually exlusive, except for -e
NOTE: This script assumes that the internal display is named LVDS1

EXAMPLES:

* to toggle two monitors, HDMI1 and VGA1 with the internal display:

	toggledisplay -t -e "HDMI1 VGA1"

* to toggle all connected external displays with the internal display:

	toggledisplay -t

EOF
}

while getopts "htmde:" OPTION
do
	case $OPTION in
	h)
		toggledisplay_usage
		exit 0
		;;
	t)
		toggle=1
		;;
	m)
		mirror=1
		;;
	d)
		discon=1
		;;
	e)
		externs=$OPTARG
		;;
	?)
		toggledisplay_usage
		exit 0
		;;
	esac
done

if [[ $OPTIND == 1 ]]
then # default to toggle.
	toggle=1
fi

# default internal display:
int="LVDS1"
# TODO: make this configurable?

# get the script path:
spath=$(cd $(dirname $0); pwd -P)
# NOTE: above only needed to resolve listmodes.awk
# TODO: make listmodes.awk internal?  It is pretty short...

# grab the current state of our monitors
xrr=$(xrandr -q --current)
# NOTE: --current makes xrandr return much faster, since it does not have
# to poll the hardware.  In my experience, polling is not necessary: e.g.,
# if I plug in a VGA cable and then immediately run xrandr --current, the
# newly attached VGA shows up in the list.

# get the list of external monitors if it has not been provided.
if [[ -z $externs ]]; then
	externs=$(awk '/\<connected\>/ {print $1}' <<< "$xrr")
	# remove the internal display from the list:
	externs=${externs//$int/}
fi

# if there are no external displays found, then there isn't much to do,
# so we should bail out here.
if [[ -z ${externs// /} ]]; then
	echo "No external displays found."
	exit 1;
fi

# TODO: more testing.

# list of commands:
cmds=( --off --auto )
if [[ $toggle == 1 ]]; then
	# figure out if the internal is on, and set the command based on that.
	( echo "$xrr" | grep "$int" | grep -q "+" ) && k=1 || k=0

	xrcmd=""
	for ext in $externs; do
		xrcmd="$xrcmd --output $ext ${cmds[$k]}"
	done
	xrandr $xrcmd --output $int ${cmds[($k+1)%2]}
	# return with status of last operation:
	exit
fi

# for the moment, we'll try to mirror with the first external
# and ignore all the other ones.  A more general solution might
# be to compute the set intersection of all externals.
if [[ $mirror == 1 ]]; then
	# grab the available modes using listmodes.awk:
	xa=($externs)
	extmodes=$(awk -f "$spath"/listmodes.awk -v output="${xa[0]}" <<< "$xrr")
	intmodes=$(awk -f "$spath"/listmodes.awk -v output="$int" <<< "$xrr")

	# compute the intersection and select the maximal element:
	modes=($(comm -12 <(sort <<< "$extmodes") <(sort <<< "$intmodes") | sort -gr))
	if (( ${#modes[@]} == 0 )); then
		echo "No compatible modes found x_x" 1>&2
		exit 1
	fi
	best=${modes[0]}

	# NOTE: we define the "best" match by using the width as a high-order
	# key and the height as a low order key.  This may not yield the highest
	# resolution in terms of the pixel count.

	xrandr --output ${xa[0]} --mode $best --output $int --mode $best \
		--same-as ${xa[0]}
	exit
fi

if [[ $discon == 1 ]]; then
	xrcmd=""
	for ext in $externs; do
		xrcmd="$xrcmd --output $ext --off"
	done
	xrandr $xrcmd --output $int --auto
fi
